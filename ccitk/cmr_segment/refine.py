import mirtk
import numpy as np
from pathlib import Path

from ccitk.cmr_segment.common.constants import RESOURCE_DIR
from ccitk.common.resource import Segmentation, PhaseImage
from ccitk.common.data_table import DataTable
from ccitk.refine import refine_segmentation_with_atlases


mirtk.subprocess.showcmd = True


class SegmentationRefiner:
    """
    Refiner uses multi-atlas registration to refine segmentations generated by the segmentor.
    For each segmentation, it first finds top similar atlases, then registers the segmentation with each atlas,
    and finally fuses the labels of all transformed atlases and outputs as the refined segmentation.

    It takes input from

    .. code-block:: text

        /path/
            subject1/
                lvsa_SR_ED.nii.gz               ->  Enlarged ED image
                lvsa_SR_ES.nii.gz               ->  Enlarged ES image
                seg_lvsa_SR_ED.nii.gz           ->  ED segmentation
                seg_lvsa_SR_ES.nii.gz           ->  ES segmentation
                landmark_ED.vtk                 ->  ED landmarks
                landmark_ES.vtk                 ->  ES landmarks
            subject2/
                ...

    and generates output

    .. code-block:: text

        /path/
            subject1/
                refine/
                    tmp/                                        ->  Temporary files
                    seg_lvsa_SR_ED.nii_refined.nii.gz           ->  Refined ED segmentation
                    seg_lvsa_SR_ES.nii_refined.nii.gz           ->  Refined ES segmentation
            subject2/
                ...

    To run only the refiner, use one of the following commands:

    .. code-block:: text

        ccitk-cmr-segment -o /output-dir/ --data-dir /input-dir/ --refine --csv-path /path-to-csv --n-top 7
    """
    def __init__(self, csv_path: Path, n_atlas: int = None, param_path: Path = None):
        assert csv_path.exists(), "Path to csv file containing list of atlases must exist. "
        data_table = DataTable.from_csv(csv_path)
        label_paths = data_table.select_column("label_path")
        landmarks = []
        atlases = []
        for idx, path in enumerate(label_paths):
            if idx % 2 == 0:
                if Path(path).parent.joinpath("landmarks2.vtk").exists():
                    atlases.append(Path(path))
                    landmarks.append(Path(path).parent.joinpath("landmarks2.vtk"))
        print("Total {} atlases with landmarks...".format(len(atlases)))
        if n_atlas is not None:
            if n_atlas < len(atlases):
                print("Randomly choosing {} atlases...".format(n_atlas))
                indices = np.random.choice(np.arange(len(atlases)), n_atlas, replace=False)
                atlases = np.array(atlases)
                landmarks = np.array(landmarks)
                atlases = atlases[indices].tolist()
                landmarks = landmarks[indices].tolist()
                print("Total {} atlases remained...".format(len(atlases)))

        self.atlases = atlases
        self.landmarks = landmarks
        if param_path is None:
            param_path = RESOURCE_DIR.joinpath("ffd_label_1.cfg")
        self.param_path = param_path
        self.affine_param_path = RESOURCE_DIR.joinpath("segareg_2.txt")

    def run(self, subject_image: PhaseImage, subject_seg: Segmentation, subject_landmarks: Path, output_dir: Path,
            n_top: int, force: bool) -> Segmentation:
        """Run multi-atlas registration to refine segmentation, given subject image, segmentation and landmarks.

        Args:
            subject_image: enlarged subject subject (ED/ES)
            subject_seg: subject segmentation by Segmentor
            subject_landmarks: subject lanmarks according to initial segmentation
            output_dir: output directory
            n_top: number of top similar atlas to use
            force: whether to overwrite outputs if exist

        Returns:

        """
        output_path = output_dir.joinpath(subject_seg.path.stem + "_refined.nii.gz")
        output_path.parent.mkdir(parents=True, exist_ok=True)

        refine_segmentation_with_atlases(
            atlases_label=self.atlases,
            atlases_landmark=self.landmarks,
            subject_segmentation=subject_seg.path,
            subject_image=subject_image.path,
            subject_landmarks=subject_landmarks,
            affine_parin=self.affine_param_path,
            ffd_parin=self.param_path,
            output_path=output_path,
            n_top=n_top,
            overwrite=force,
            phase=str(subject_image.phase),
        )

        return Segmentation(
            path=output_path,
            phase=subject_seg.phase
        )
